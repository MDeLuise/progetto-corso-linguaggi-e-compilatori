module AbsGrammar where

-- Haskell module generated by the BNF converter

import LexGrammar(Posn)
import Type

data Ident a = Ident {identContent:: a, identString:: String} deriving (Eq, Ord, Show, Read)
data Boolean a = Boolean_true {booleanContent:: a } | Boolean_false { booleanContent:: a} deriving (Eq, Ord, Show, Read)
data MyInteger a = MyInteger {myIntegerContent:: a, myIntegerInt:: Integer} deriving (Eq, Ord, Show, Read)
data MyChar a = MyChar {myCharContent:: a, myCharChar:: Char } deriving (Eq, Ord, Show, Read)
data MyString a = MyString {myStringContent:: a, myStringString:: String} deriving (Eq, Ord, Show, Read)
data MyDouble a = MyDouble {myDoubleContent:: a, myDoubleDouble:: Double} deriving (Eq, Ord, Show, Read)


data BasicType a
    = BasicType_boolean {basicTypeContent:: a}
    | BasicType_char {basicTypeContent:: a}
    | BasicType_float64 {basicTypeContent:: a}
    | BasicType_int {basicTypeContent:: a}
    | BasicType_void {basicTypeContent:: a}
    | BasicType_String {basicTypeContent:: a}
  deriving (Eq, Ord, Read)


data Modality = Modality1 | Modality_val | Modality_ref | Modality_valres | Modality_const deriving (Eq, Ord, Show, Read)


data NewLine = NewLine1 deriving (Eq, Ord, Show, Read)


data Program a = Prog a (BlockDecl a) deriving (Eq, Ord, Show, Read)


data RExpr a
    = BoolBinOp {rexprContent:: a, rexprAddr:: Addr, rexprBoolOp:: BoolOp, rexprFstOperand:: (RExpr a), rexprSndOperand:: (RExpr a)}
    | Not {rexprContent:: a, rexprAddr:: Addr, rexprOperand:: (RExpr a)}
    | Equality {rexprContent:: a, rexprAddr:: Addr, rexprEqOp:: EqOp, rexprFstOperand:: (RExpr a), rexprSndOperand:: (RExpr a)}
    | Comparison {rexprContent:: a, rexprAddr:: Addr, rexprCompOp:: CoOp, rexprFstOperand:: (RExpr a), rexprSndOperand:: (RExpr a)}
    | BinOp {rexprContent:: a, rexprAddr:: Addr, rexprOp:: Op, rexprFstOperand:: (RExpr a), rexprSndOperand:: (RExpr a)}
    | Neg {rexprContent:: a, rexprAddr:: Addr, rexprOperand:: (RExpr a)}
    | Ref {rexprContent:: a, rexprAddr:: Addr, rexprRef:: (LExpr a)}
    | FCall {rexprContent:: a, rexprAddr:: Addr, rexprIdent:: (Ident a), rexprParams:: [(RExpr a)]}
    | Int {rexprContent:: a, rexprAddr:: Addr, rexprInt:: (MyInteger a)}
    | Char {rexprContent:: a, rexprAddr:: Addr, rexprChar:: (MyChar a)}
    | String {rexprContent:: a, rexprAddr:: Addr, rexprString:: (MyString a)}
    | Float {rexprContent:: a, rexprAddr:: Addr, rexprDouble:: (MyDouble a)}
    | Bool {rexprContent:: a, rexprAddr:: Addr, rexprBoolean:: (Boolean a)}
    | Lexpr {rexprContent:: a, rexprAddr:: Addr, rexprLexp:: (LExpr a)}
    | IfRe {rexprContent:: a, rexprAddr:: Addr, rexprGuard:: (RExpr a), rexprThen:: (RExpr a), rexprElse:: (RExpr a)}
    | PreCalc {rexprContent:: a, rexprAddr:: Addr} -- internal use only
  deriving (Eq, Ord, Show, Read)


data Op = Add | Sub | Mul | Div | Mod | Pow deriving (Eq, Ord, Show, Read)
  

data BoolOp = And | Or deriving (Eq, Ord, Show, Read)
  

data EqOp = Eq | Neq deriving (Eq, Ord, Show, Read)
  

data CoOp = Lt | LtE | Gt | GtE deriving (Eq, Ord, Show, Read)
  

data LExpr a
    = Deref {lexprContent:: a, lexprAddr:: Addr, lexprDeref:: (RExpr a)}
    | IncDec {lexprContent:: a, lexprAddr:: Addr, lexprIncDecOp:: IncDecOp, lexprOperand:: (LExpr a)}
    | BasLExpr {lexprContent:: a, lexprAddr:: Addr, lexprBlexpr:: (BLExpr a)}
  deriving (Eq, Ord, Show, Read)


data IncDecOp = PreInc | PostInc | PreDecr | PostDecr deriving (Eq, Ord, Show, Read)
  

data BLExpr a
    = ArrayEl {blexprContent:: a, blexprAddr:: Addr, blexprArray:: Addr, blexprBlexpr:: (BLExpr a), blexprRexpr:: (RExpr a)}
    | Id {blexprContent:: a, blexprAddr:: Addr, blexprArray:: Addr, blexprId:: String}
    | ParLExpr {blexprContent:: a, blexprAddr:: Addr, blexprArray:: Addr, blexprlexpr:: (LExpr a)}
  deriving (Eq, Ord, Show, Read)


data TypeSpec a
    = BasTyp {typeSpecContent:: a, basicTypeBasicType:: (BasicType a)}
    | ArrDef {typeSpecContent:: a, typeSpecTypeSpec:: (TypeSpec a), typeSpecDim:: (MyInteger a)}
    | ArrUnDef {typeSpecContent:: a, typeSpecTypeSpec:: (TypeSpec a)}
    | Pointer {typeSpecContent:: a, typeSpecTypeSpec:: (TypeSpec a)}
  deriving (Eq, Ord, Show, Read)


data VarDeclInit a
    = VarDeclIn {varDeclInitContent:: a, varDeclInitAddr:: Addr, varDeclInitIdent:: (Ident a), varDeclInitType:: (TypeSpec a), varDeclInitComplexRexpr:: (ComplexRExpr a), varDeclInitCheck:: Bool}
    | ConDeclIn {varDeclInitContent:: a, varDeclInitAddr:: Addr, varDeclInitIdent:: (Ident a), varDeclInitType:: (TypeSpec a), varDeclInitComplexRexpr:: (ComplexRExpr a), varDeclInitCheck:: Bool}
  deriving (Eq, Ord, Show, Read)


data ComplexRExpr a
    = Simple {complexRexprContent:: a, complexRexprAddr:: Addr, complexRexprRexpr:: (RExpr a)}
    | Array {complexRexprContent:: a, complexRexprAddr:: Addr, complexRexprListRexpr:: [(ComplexRExpr a)]}
  deriving (Eq, Ord, Show, Read)


data Parameter a = Param {paramContent:: a, paramAddr:: Addr, paramMod:: Modality, paramId:: (Ident a), paramTypeSpec:: (TypeSpec a)}
  deriving (Eq, Ord, Show, Read)


data Stmt a
    = Comp {stmtContent:: a, stmtBlockDecl:: (BlockDecl a)}
    | ProcCall {stmtContent:: a, stmtCallIdent:: (Ident a), stmtCallParams:: [(RExpr a)]}
    | Jmp {stmtContent:: a, stmtJumpStmt:: (JumpStmt a)}
    | While {stmtContent:: a, stmtGuard:: (RExpr a), stmtBlock:: (BlockDecl a)}
    | DoWhile {stmtContent:: a, stmtGuard:: (RExpr a), stmtBlock:: (BlockDecl a)}
    | For {stmtContent:: a, stmtVarId:: (Ident a), stmtStart:: (RExpr a), stmtFinish:: (RExpr a), stmtBlock:: (BlockDecl a)}
    | Sel {stmtContent:: a, stmtSelectionStmt:: (SelectionStmt a)}
    | Assgn {stmtContent:: a, stmtLexpr:: (LExpr a), stmtAssOp:: (Assignment_op a), stmtRexpr:: (RExpr a)}
    | LExprStmt {stmtContent:: a, stmtLexpr:: (LExpr a)}
    | VarDec {stmtContent:: a, stmtVarDecl:: (VarDeclInit a)}
    | FunDec {stmtContent:: a, stmtIdent:: (Ident a), stmtFormalParams:: [(Parameter a)], stmtTypeReturn:: (TypeSpec a), stmtFuncBody:: (BlockDecl a)}
    | Switch {stmtContent:: a, stmtExpr:: (RExpr a), stmtSwitchBlock:: (SwitchBlock a)}
    | Goto {stmtContent:: a, stmtDest:: Lab} -- internal use only
  deriving (Eq, Ord, Show, Read)


data SwitchBlock a = BlockSwitch {switchBlockContent:: a, switchBlockMatches:: [SwitchMatch a]}
  deriving (Eq, Ord, Show, Read)


data SwitchMatch a
    = Match {matchContent:: a, matchRExpr:: (RExpr a), matchBlock:: (BlockDecl a)}
    | Default {matchContent:: a, matchBlock:: (BlockDecl a)}
  deriving (Eq, Ord, Show, Read)


data BlockDecl a = Block {blockDeclContent:: a, blockDeclListStmt:: [(Stmt a)]}
  deriving (Eq, Ord, Show, Read)


data Assignment_op a
    = Assign {assignmentOpContent:: a}
    | AssgnMul {assignmentOpContent:: a}
    | AssgnAdd {assignmentOpContent:: a}
    | AssgnDiv {assignmentOpContent:: a}
    | AssgnSub {assignmentOpContent:: a}
    | AssgnPow {assignmentOpContent:: a}
    | AssgnAnd {assignmentOpContent:: a}
    | AssgnOr {assignmentOpContent:: a} 
  deriving (Eq, Ord, Show, Read)


data JumpStmt a
    = Break {jumpStmtContent:: a}
    | Continue {jumpStmtContent:: a}
    | RetExpVoid {jumpStmtContent:: a}
    | RetExp {jumpStmtContent:: a, jumpStmtRexpr:: (RExpr a)}
  deriving (Eq, Ord, Show, Read)


data SelectionStmt a
    = IfNoElse {selectionStmtContent:: a, selectionStmtGuard:: (RExpr a), selectionStmtBlockThen:: (BlockDecl a)}
    | IfElse {selectionStmtContent:: a, selectionStmtGuard:: (RExpr a), selectionStmtBlockThen:: (BlockDecl a), selectionStmtBlockElse:: (BlockDecl a)}
  deriving (Eq, Ord, Show, Read)


data Addr
    = CString {addrString:: String}
    | CAddr {addrString:: String}
    | CInt {addrInt:: Integer}
    | CBool {addrBool:: Bool}
    | CDouble {addrDouble:: Double}
    | CChar {addrChar:: Char}
    | CList {addrAddrs:: [Addr], addrTypes:: [Type]}
    | CArrInfo {addrAddr1:: Addr, addrAddr2:: Addr, addrCheck:: Bool}
    deriving (Eq, Ord, Read)


type Lab = String

instance Show Addr where
  show a = case a of
    CString str -> show str
    CAddr str -> str
    CInt num -> show num
    CBool bol -> case bol of
      True -> "true"
      False -> "false"
    CDouble d -> show d
    CChar c -> show c


-- SHOW instaces below


instance (Show a) => Show (BasicType a) where
  show ty = case ty of
    BasicType_boolean content -> "boolean (" ++ show content ++ ")" 
    BasicType_char content -> "char(" ++ show content ++ ")" 
    BasicType_float64 content -> "float64 (" ++ show content ++ ")" 
    BasicType_int content -> "int (" ++ show content ++ ")" 
    BasicType_void content -> "void (" ++ show content ++ ")" 
    BasicType_String content -> "string (" ++ show content ++ ")" 
