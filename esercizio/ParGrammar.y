-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGrammar where
import AbsGrammar
import LexGrammar
import ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '
' { PT _ (TS _ 1) }
  '!' { PT _ (TS _ 2) }
  '!=' { PT _ (TS _ 3) }
  '%' { PT _ (TS _ 4) }
  '&' { PT _ (TS _ 5) }
  '&&' { PT _ (TS _ 6) }
  '&=' { PT _ (TS _ 7) }
  '(' { PT _ (TS _ 8) }
  ')' { PT _ (TS _ 9) }
  '*' { PT _ (TS _ 10) }
  '**' { PT _ (TS _ 11) }
  '**=' { PT _ (TS _ 12) }
  '*=' { PT _ (TS _ 13) }
  '+' { PT _ (TS _ 14) }
  '++' { PT _ (TS _ 15) }
  '+=' { PT _ (TS _ 16) }
  ',' { PT _ (TS _ 17) }
  '-' { PT _ (TS _ 18) }
  '--' { PT _ (TS _ 19) }
  '-=' { PT _ (TS _ 20) }
  '..' { PT _ (TS _ 21) }
  '/' { PT _ (TS _ 22) }
  '/=' { PT _ (TS _ 23) }
  ':' { PT _ (TS _ 24) }
  ':=' { PT _ (TS _ 25) }
  ';' { PT _ (TS _ 26) }
  '<' { PT _ (TS _ 27) }
  '<=' { PT _ (TS _ 28) }
  '==' { PT _ (TS _ 29) }
  '>' { PT _ (TS _ 30) }
  '>=' { PT _ (TS _ 31) }
  '?' { PT _ (TS _ 32) }
  'String' { PT _ (TS _ 33) }
  '[' { PT _ (TS _ 34) }
  ']' { PT _ (TS _ 35) }
  '^' { PT _ (TS _ 36) }
  '_' { PT _ (TS _ 37) }
  '`' { PT _ (TS _ 38) }
  'boolean' { PT _ (TS _ 39) }
  'break' { PT _ (TS _ 40) }
  'char' { PT _ (TS _ 41) }
  'checked' { PT _ (TS _ 42) }
  'const' { PT _ (TS _ 43) }
  'continue' { PT _ (TS _ 44) }
  'def' { PT _ (TS _ 45) }
  'do' { PT _ (TS _ 46) }
  'else' { PT _ (TS _ 47) }
  'false' { PT _ (TS _ 48) }
  'float64' { PT _ (TS _ 49) }
  'for' { PT _ (TS _ 50) }
  'if' { PT _ (TS _ 51) }
  'in' { PT _ (TS _ 52) }
  'int' { PT _ (TS _ 53) }
  'match' { PT _ (TS _ 54) }
  'ref' { PT _ (TS _ 55) }
  'return' { PT _ (TS _ 56) }
  'switch' { PT _ (TS _ 57) }
  'true' { PT _ (TS _ 58) }
  'val' { PT _ (TS _ 59) }
  'valres' { PT _ (TS _ 60) }
  'var' { PT _ (TS _ 61) }
  'void' { PT _ (TS _ 62) }
  'while' { PT _ (TS _ 63) }
  '{' { PT _ (TS _ 64) }
  '|=' { PT _ (TS _ 65) }
  '||' { PT _ (TS _ 66) }
  '}' { PT _ (TS _ 67) }
  '~' { PT _ (TS _ 68) }

L_ident  { PT _ (TV _) }
L_integ  { PT _ (TI _) }
L_charac { PT _ (TC _) }
L_quoted { PT _ (TL _) }
L_doubl  { PT _ (TD _) }



-- Added NOT by bnfc
%left '||'
%left '&&'
%nonassoc '!'
%nonassoc '==' '!=' '>' '>=' '<' '<='
%left '+' '-' '%'
%left '*' '/'
%right '**'
%nonassoc '++' '--'
%nonassoc '~'
-- .


%%

Ident   :: { Ident Posn }   : L_ident  { Ident (tokenPosn $1) (getTokenContent $1) }
MyInteger :: { MyInteger Posn } : L_integ { MyInteger (tokenPosn $1) ((read ( (getTokenContent $1))) :: Integer) }
MyChar :: { MyChar Posn } : L_charac { MyChar (tokenPosn $1) ((read ( (getTokenContent $1))) :: Char) }
MyString :: { MyString Posn } : L_quoted { MyString (tokenPosn $1) (getTokenContent $1) }
MyDouble :: { MyDouble Posn } : L_doubl { MyDouble (tokenPosn $1) ((read ( (getTokenContent $1))) :: Double) }

Boolean :: { Boolean Posn }
Boolean : 'true' { AbsGrammar.Boolean_true (tokenPosn $1) }
        | 'false' { AbsGrammar.Boolean_false (tokenPosn $1) }
BasicType :: { BasicType Posn }
BasicType : 'boolean' { AbsGrammar.BasicType_boolean (tokenPosn $1) }
          | 'char' { AbsGrammar.BasicType_char (tokenPosn $1) }
          | 'float64' { AbsGrammar.BasicType_float64 (tokenPosn $1) }
          | 'int' { AbsGrammar.BasicType_int (tokenPosn $1) }
          | 'void' { AbsGrammar.BasicType_void (tokenPosn $1) }
          | 'String' { AbsGrammar.BasicType_String (tokenPosn $1) }
Modality :: { Modality }
Modality : {- empty -} { AbsGrammar.Modality1 }
         | 'val' { AbsGrammar.Modality_val }
         | 'ref' { AbsGrammar.Modality_ref }
         | 'valres' { AbsGrammar.Modality_valres }
         | 'const' { AbsGrammar.Modality_const }
NewLine :: { NewLine }
NewLine : '
' { AbsGrammar.NewLine1 }
Program :: { Program Posn }
Program : BlockDecl ';' { AbsGrammar.Prog (Pn 0 1 1) $1 }
ListRExpr :: { [(RExpr Posn)] }
ListRExpr : {- empty -} { [] }
          | RExpr { (:[]) $1 }
          | RExpr ',' ListRExpr { (:) $1 $3 }
RExpr :: { RExpr Posn }
RExpr : RExpr '||' RExpr { AbsGrammar.BoolBinOp (tokenPosn $2) (CString "") Or $1 $3 }
      | RExpr '&&' RExpr { AbsGrammar.BoolBinOp (tokenPosn $2) (CString "") And $1 $3 }
      | '!' RExpr { AbsGrammar.Not (tokenPosn $1) (CString "") $2 }
      | RExpr '==' RExpr { AbsGrammar.Equality (tokenPosn $2) (CString "") Eq $1 $3 }
      | RExpr '!=' RExpr { AbsGrammar.Equality (tokenPosn $2) (CString "") Neq $1 $3 }
      | RExpr '<' RExpr { AbsGrammar.Comparison (tokenPosn $2) (CString "") Lt $1 $3 }
      | RExpr '<=' RExpr { AbsGrammar.Comparison (tokenPosn $2) (CString "") LtE $1 $3 }
      | RExpr '>' RExpr { AbsGrammar.Comparison (tokenPosn $2) (CString "") Gt $1 $3 }
      | RExpr '>=' RExpr { AbsGrammar.Comparison (tokenPosn $2) (CString "") GtE $1 $3 }
      | RExpr '+' RExpr { AbsGrammar.BinOp (tokenPosn $2) (CString "") Add $1 $3 }
      | RExpr '-' RExpr { AbsGrammar.BinOp (tokenPosn $2) (CString "") Sub $1 $3 }
      | RExpr '*' RExpr { AbsGrammar.BinOp (tokenPosn $2) (CString "") Mul $1 $3 }
      | RExpr '/' RExpr { AbsGrammar.BinOp (tokenPosn $2) (CString "") Div $1 $3 }
      | RExpr '%' RExpr { AbsGrammar.BinOp (tokenPosn $2) (CString "") Mod $1 $3 }
      | RExpr '**' RExpr { AbsGrammar.BinOp (tokenPosn $2) (CString "") Pow $1 $3 }
      | '-' RExpr { AbsGrammar.Neg (tokenPosn $1) (CString "") $2 }
      | '&' LExpr { AbsGrammar.Ref (tokenPosn $1) (CString "") $2 }
      | Ident '(' ListRExpr ')' { AbsGrammar.FCall (tokenPosn $2) (CString "")  $1 $3 }
      | MyInteger { AbsGrammar.Int (myIntegerContent $1) (CString "") $1 }
      | MyChar { AbsGrammar.Char (myCharContent $1) (CString "") $1 }
      | MyString { AbsGrammar.String (myStringContent $1) (CString "") $1 }
      | MyDouble { AbsGrammar.Float (myDoubleContent $1) (CString "") $1 }
      | Boolean { AbsGrammar.Bool (booleanContent $1) (CString "") $1 }
      |'(' RExpr ')' { $2 }
      | LExpr { AbsGrammar.Lexpr (lexprContent $1) (CString "") $1 }
      | '`' RExpr '`' '?' '`' RExpr '`' '^' '`' RExpr '`' { AbsGrammar.IfRe (rexprContent $2) (CString "") $2 $6 $10 }
LExpr :: { LExpr Posn }
LExpr : LExpr1 { $1 }
      | '~' RExpr { AbsGrammar.Deref (tokenPosn $1) (CString "") $2 }
      | '++' LExpr1 { AbsGrammar.IncDec (tokenPosn $1) (CString "") PreInc $2 }
      | '--' LExpr1 { AbsGrammar.IncDec (tokenPosn $1) (CString "") PreDecr $2 }
LExpr1 :: { LExpr Posn }
LExpr1 : LExpr2 { $1 }
       | LExpr2 '++' { AbsGrammar.IncDec (tokenPosn $2) (CString "")  PostInc $1 }
       | LExpr2 '--' { AbsGrammar.IncDec (tokenPosn $2) (CString "") PostDecr $1 }
LExpr2 :: { LExpr Posn }
LExpr2 : BLExpr { AbsGrammar.BasLExpr (blexprContent $1) (CString "") $1 }
BLExpr :: { BLExpr Posn }
BLExpr : BLExpr '[' RExpr ']' { AbsGrammar.ArrayEl (tokenPosn $2) (CString "") (CString "") $1 $3 }
       | Ident { AbsGrammar.Id (identContent $1) (CString "") (CString "") (identString $1) }
       | '(' LExpr ')' { AbsGrammar.ParLExpr (lexprContent $2) (CString "") (CString "") $2 }
TypeSpec :: { TypeSpec Posn }
TypeSpec : BasicType { AbsGrammar.BasTyp (basicTypeContent $1) $1 }
         | TypeSpec '[' MyInteger ']' { AbsGrammar.ArrDef (typeSpecContent $1) $1 $3 }
		 | TypeSpec '[' ']' { AbsGrammar.ArrUnDef (typeSpecContent $1) $1 }
		 | TypeSpec '~' { AbsGrammar.Pointer (typeSpecContent $1) $1 } 
VarDeclInit :: { VarDeclInit Posn }
VarDeclInit : 'var' Ident ':' TypeSpec ':=' ComplexRExpr { AbsGrammar.VarDeclIn (tokenPosn $1) (CString "") $2 $4 $6 False}
            | 'def' Ident ':' TypeSpec ':=' ComplexRExpr { AbsGrammar.ConDeclIn (tokenPosn $1) (CString "") $2 $4 $6 False}
CheckedDecl :: { VarDeclInit Posn }
CheckedDecl : 'checked' VarDeclInit { $2 {varDeclInitCheck = True} }
            | VarDeclInit { $1 }
ComplexRExpr :: { ComplexRExpr Posn }
ComplexRExpr : RExpr { AbsGrammar.Simple (rexprContent $1) (CString "") $1 }
             | '[' ListComplexRExpr ']' { AbsGrammar.Array (complexRexprContent (head $2)) (CString "") $2 }
ListComplexRExpr :: { [(ComplexRExpr Posn)] }
ListComplexRExpr : ComplexRExpr { (:[]) $1 }
                 | ComplexRExpr ',' ListComplexRExpr { (:) $1 $3 }
ListParameter :: { [(Parameter Posn)] }
ListParameter : {- empty -} { [] }
              | Parameter { (:[]) $1 }
              | Parameter ',' ListParameter { (:) $1 $3 }
Parameter :: { Parameter Posn }
Parameter : Modality Ident ':' TypeSpec { AbsGrammar.Param (identContent $2) (CString "") $1 $2 $4 }
ListStmt :: { [(Stmt Posn)] }
ListStmt : {- empty -} { [] }
         | Stmt { (:[]) $1 }
         | Stmt ';' ListStmt { (:) $1 $3 }
Stmt :: { Stmt Posn }
Stmt : BlockDecl { AbsGrammar.Comp (blockDeclContent $1) $1 }
     | Ident '(' ListRExpr ')' { AbsGrammar.ProcCall (tokenPosn $2) $1 $3 }
     | JumpStmt { AbsGrammar.Jmp (jumpStmtContent $1) $1 }
     | 'while' '(' RExpr ')' BlockDecl { AbsGrammar.While (tokenPosn $1) $3 $5 }
     | 'do' BlockDecl 'while' '(' RExpr ')' { AbsGrammar.DoWhile (tokenPosn $1) $5 $2 }
     | 'for' Ident 'in' RExpr '..' RExpr BlockDecl { AbsGrammar.For (tokenPosn $1) $2 $4 $6 $7 }
     | SelectionStmt { AbsGrammar.Sel (selectionStmtContent $1) $1 }
     | LExpr Assignment_op RExpr { AbsGrammar.Assgn (assignmentOpContent $2) $1 $2 $3 }
     | LExpr { AbsGrammar.LExprStmt (lexprContent $1) $1 }
     | CheckedDecl { AbsGrammar.VarDec (varDeclInitContent $1) $1 }
     | 'def' Ident '(' ListParameter ')' ':' TypeSpec BlockDecl { AbsGrammar.FunDec (tokenPosn $1) $2 $4 $7 $8 }
     | 'switch' '(' RExpr ')' SwitchBlock { AbsGrammar.Switch (tokenPosn $1) $3 $5 }
     | '(' Stmt ')' { $2 }
     | Stmt ';' { $1 }
SwitchBlock :: { SwitchBlock Posn }
SwitchBlock : '{' ListSwitchMatch '}' { AbsGrammar.BlockSwitch (tokenPosn $1) $2 }
SwitchMatch :: { SwitchMatch Posn }
SwitchMatch : 'match' RExpr BlockDecl { AbsGrammar.Match (tokenPosn $1) $2 $3 }
SwitchMatch : 'match' '_' BlockDecl { AbsGrammar.Default (tokenPosn $1) $3 }
ListSwitchMatch :: { [SwitchMatch Posn] }
ListSwitchMatch : {- empty -} { [] }
                | SwitchMatch { (:[]) $1 }
                | SwitchMatch ';' ListSwitchMatch { (:) $1 $3 }
BlockDecl :: { BlockDecl Posn }
BlockDecl : '{' ListStmt '}' { AbsGrammar.Block (tokenPosn $1) $2 }
Assignment_op :: { Assignment_op Posn }
Assignment_op : ':=' { AbsGrammar.Assign (tokenPosn $1) }
              | '*=' { AbsGrammar.AssgnMul (tokenPosn $1) }
              | '+=' { AbsGrammar.AssgnAdd (tokenPosn $1) }
              | '/=' { AbsGrammar.AssgnDiv (tokenPosn $1) }
              | '-=' { AbsGrammar.AssgnSub (tokenPosn $1) }
              | '**=' { AbsGrammar.AssgnPow (tokenPosn $1) }
              | '&=' { AbsGrammar.AssgnAnd (tokenPosn $1) }
              | '|=' { AbsGrammar.AssgnOr (tokenPosn $1) }
JumpStmt :: { JumpStmt Posn }
JumpStmt : 'break' { AbsGrammar.Break (tokenPosn $1) }
         | 'continue' { AbsGrammar.Continue (tokenPosn $1) }
         | 'return' { AbsGrammar.RetExpVoid (tokenPosn $1) }
         | 'return' RExpr { AbsGrammar.RetExp (tokenPosn $1) $2 }
SelectionStmt :: { SelectionStmt Posn }
SelectionStmt : 'if' '(' RExpr ')' BlockDecl { AbsGrammar.IfNoElse (tokenPosn $1) $3 $5 }
              | 'if' '(' RExpr ')' BlockDecl 'else' BlockDecl { AbsGrammar.IfElse (tokenPosn $1) $3 $5 $7 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    (PT _ (TL " ")):xs -> ", before this characters: ;"      -- Added NOT by bnfc these left cases
    _ -> ", before these characters: " ++ unwords (map (changeSemicolonToNewLine . prToken) (take 4 ts))

myLexer = tokens


-- Added NOT by bnfc
getTokenContent (PT _ (TV s)) = s
getTokenContent (PT _ (TI s)) = s
getTokenContent (PT _ (TC s)) = s
getTokenContent (PT _ (TL s)) = s
getTokenContent (PT _ (TD s)) = s

changeSemicolonToNewLine :: String -> String
changeSemicolonToNewLine ";" = "\"new line\""
changeSemicolonToNewLine s = s
-- .
}

